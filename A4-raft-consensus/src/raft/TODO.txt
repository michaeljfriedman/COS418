Part I - Appending log entries and reaching consensus
-----------------------------------------------------

>>> Write in debug print statements as you go!


* Implement data types
  * Raft
    * Lock-able commitIndex/lastApplied (lock the whole Raft obj)
  * LogEntry
  * AppendEntriesArgs
  * AppendEntriesReply

* Implement Start(), "when I become leader" (easy)

* Interlude: Make separate debug flag for leader election and consensus

* Interlude: if log is indexed from 1, make sure first commit works

* Implement leader functions:
  * doConsensus()
  * applyLogEntries()
  * sendAppendEntries()  (overwrites old sendAppendEntries)
  * sendPeriodicHeartbeats()

* Implement follower functions:
  * AppendEntries()
  * logsMatchThrough()

- Debug tests:
  * TestBasicAgree
  * TestFailAgree
  - TestFailNoAgree
  - TestConcurrentStarts
  - TestRejoin
  - TestBackup
  - TestCount
  - Remove AppendEntriesArgs Id attr and Raft appendEntriesId attr before moving on (?)

- Fix leader election bug?
  - At one point I got a failure in the second leader election test (from A3),
    where server 0 claimed to be leader even though no leader should have been
    elected... but this only happened once and never happened again. Weird...


Part II - Handling failures/persistence
---------------------------------------




Part III - Optimization
-----------------------


--------------------------------------------------------------------------------


Suggestions from listening at lab TAs:
--------------------------------------
- In general, any read of log-related data (log, commitIndex, lastApplied, etc.)
  requires a lock in advance.
- You can usually just lock an entire function, even if you only need the lock
  for part of it. They execute quickly anyway, so it doesn't cause much delay.
  But *don't* lock things that take a while to run:
  - When RPC is sent
  - for loops
  - Waiting for outcomes (e.g. consensusOutcome in doConsensus())
- In particular, lock entire AppendEntries handler


- You can't assume you remain the leader throughout an entire function,
  unless it's locked. If you're about to acquire a lock to do something
  leader-specific (e.g. apply entries in sendAppendEntries()), check that
  you're still leader before you do it.


- If you need to reference log size throughout a whole function, store it
  at the beginning and use that size, since it could change throughout the
  function.


- Consider this sequence (election):
  - Term 0: 2 wants to run. Votes for himself and requests votes
  - Term 0: 1 wants to run:
      if rf.votedFor == NoOne {      <-- this line executes
        go rf.runForLeader()
      }
  - Term 0: 1 receives RequestVote from 2. Grants vote and *sets term* to 1
  - Term 1: 1 executes runForLeader(). *Increments term again* to 2.

  Now 1 has effectively skipped a term. Fix:
  - Move "if rf.votedFor == NoOne" into runForLeader()
  - Lock runForLeader() while it runs



What I can/should do now
------------------------
* Lock for doConsensus:
  * Start() should return nextIndex[rf.me] instead of len(rf.log)
  * doConsensus() should lock from beginning until entry has been appended to
    log, and nextIndex is updated

* Lock for elections:
  * Lock all of RequestVote()
  * Move "if rf.voterFor == NoOne" from waitForLeaderToDie() to runForLeader()
  * Lock runForLeader() from the if statement above until I've finished
    voting for myself

