TODO

Fri 1/12:
* Re-familiarize with the assignment
* Design
* Implement nearly all of the server

Sat 1/13:
* Server: Add debug statements in the code you have so far
* Work on isDuplicate()

* Need to catch edge case: Say I (server) get an op and call Start() for it,
  but it times out. So I tell the client to retry. A server will *not* reply
  "success" to the client about an op unless there is an appliedCh for it at
  the time it is applied. So, if that retry reaches the leader before the op is
  finished/applied, then they'll get a reply. **But** if the op is applied
  *before* the retry reaches the leader, then the leader will not have an
  appliedCh for it. So he will think it's a duplicate, not Start(), and tell
  the client to retry. Other servers will deny it because they're not the
  leader. So the client will retry forever.
  * **Solution**
    * Server:
      * Add a queue "applied back log", which keeps track of ops applied but
        not yet replied to the client.
      * When an op is applied, it is added to the back log if there isn't
        currently a outstanding appliedCh for it.
      * Replying ops in the back log: Whenever the server receives an op from
        a client, it first checks if the op is in the back log, and returns its
        result to a client immediately if it is.
      * Clearing the stale back log: Whenever a server receives an op from a
        client, also clear out all ops in the back log for which the client
        says it heard successful replies (see below).
    * Client: Maintain a list of ops you heard successful replies for. When a
      successful reply comes in, add the op to that list. Then, whenever a new
      op is requested, piggy-back all ops in this list as well.
      * NOTE: This list will grow without bound. Is this ok? -- Not sure?


Sun 1/14:
* Write client
  * Design
  * Implement
  * Add debug statements

* Test up to here
  * Seems to be passing... But want to make sure it works reliably. Make a
    test-regression.sh, and run Basic test 20 or so times.


Mon 1/15:
- Part II: Detect duplicate ops    <------------------------------ YOU ARE HERE

  - Make sure to cover this case:

    Client                        Server               Raft
    ------                        ------               ----
    Request op 1 --------------->
                                  Start(1) ---------->
                                                       Start 1st occ of op 1
                                  Timeout
               <----------------- Retry op 1
    Retry op 1 ----------------->
                                  Start(1) ---------->
                                                       Start 2nd occ of op 1
                                             <-------- Committed 1st occ of op 1
                                  Apply op 1
                        <-------- Op 1 success
    Op 2, compOps = [1] -------->
                                  Rm op 1 from
                                  isApplied
                                              <------- Committed 2nd occ of op 1
                                  Apply op 1

                                ~~DUPLICATE~~

  - **Solution**. In server:
    - Allow duplicate ops to be Start()'ed, but don't *apply* them twice.
    - Make a map: op id -> bool indicating applied/not applied. Use to
      check if op was applied before applying it.
    - We need to clear this map of stale entries to save space, but it can't be
      cleared until *after* all duplicate ops have been received/ignored on
      *applyCh*

    - Add completedOps list to the Op data type

    - Every time you pull an op off applyCh:
      - If op is in the map, ignore it (i.e. don't apply).
      - Otherwise:
        - Apply it
        - Mark it applied in the map
        - Remove all completedOps from the map, and from the back log
      - Then proceed as usual.

    - Every time you receive an op from a client:
      - Construct the new Op, also including the client's list of completed ops
      - (Locked) First check if op is in the back log, and return its value if
        it is.
      - Otherwise, Start(). Then proceed as usual from here.
