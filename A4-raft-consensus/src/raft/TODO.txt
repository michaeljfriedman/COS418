Part I - Appending log entries and reaching consensus
-----------------------------------------------------

>>> Write in debug print statements as you go!


* Implement data types
  * Raft
    * Lock-able commitIndex/lastApplied (lock the whole Raft obj)
  * LogEntry
  * AppendEntriesArgs
  * AppendEntriesReply

* Implement Start(), "when I become leader" (easy)

* Interlude: Make separate debug flag for leader election and consensus

* Interlude: if log is indexed from 1, make sure first commit works

* Implement leader functions:
  * doConsensus()
  * applyLogEntries()
  * sendAppendEntries()  (overwrites old sendAppendEntries)
  * sendPeriodicHeartbeats()

* Implement follower functions:
  * AppendEntries()
  * logsMatchThrough()

* Debug tests:
  * TestBasicAgree
  * TestFailAgree
  * TestFailNoAgree
  * TestConcurrentStarts
  * TestRejoin
  * TestBackup
  * TestCount

Part I REDESIGN
---------------

**Goal**: simplify. Eliminate all consensus state maintained by the log entries themselves, and instead use just the commitIndex and matchIndex[] to keep track of what's achieved consensus.

1. Remove consensus state from log entries.

2. Remove getConsensus(). Instead, just append the entry to leader's log in Start(), and the next heartbeat will send AE *and* process the consensus.

3. Rename heartbeat-related methods: sendPeriodicUpdates(), sendRoundOfUpdates(), and sendAppendEntries() -> sendUpdateTo(). The first two remain unchanged, but sendUpdateTo() will send AE to a server and *fully* process the result (including updating consensus for the entries sent). Thus you need to cover the 3 possible consensus outcomes previously in getConsensus(): success, failure, and stale.

  - Stale: if the reply's term is later, don't process the reply. Instead, step down as leader (and update your term)
  - Failure: same as before
  - Success: same as before, but use commitIndex to determine if the entry has already been committed, and if not, use matchIndex[] to count reps and determine if you have reached consensus. Then if there's consenus, apply the entries immediately, and call sendRoundOfUpdates() in bg immediately.

4. Make sure repliers in AppendEntries() set the reply term to *their term* (after updating it, if applicable)

5. Make a new method stepDown(), which standardizes the process of stepping down, and is called anywhere the leader/candidate should step down (most notably, in the stale case in sendUpdateTo()).

(Throughout this, be careful with your use of locks. Anywhere you need to change state atomically, lock. But make sure it's not possible for some code to be waiting forever for a lock.)

6. Make sure sendRoundOfUpdates() sends all the AE messages before stepping down and clearing nextIndex[] and matchIndex[] (i.e. before the leader receives a AE failure due to old term).


Part II - Handling failures/persistence
---------------------------------------




Part III - Optimization
-----------------------


--------------------------------------------------------------------------------


Suggestions from listening at lab TAs:
--------------------------------------
- In general, any read of log-related data (log, commitIndex, lastApplied, etc.)
  requires a lock in advance.
- You can usually just lock an entire function, even if you only need the lock
  for part of it. They execute quickly anyway, so it doesn't cause much delay.
  But *don't* lock things that take a while to run:
  - When RPC is sent
  - for loops
  - Waiting for outcomes (e.g. consensusOutcome in doConsensus())
- In particular, lock entire AppendEntries handler


- You can't assume you remain the leader throughout an entire function,
  unless it's locked. If you're about to acquire a lock to do something
  leader-specific (e.g. apply entries in sendAppendEntries()), check that
  you're still leader before you do it.


- If you need to reference log size throughout a whole function, store it
  at the beginning and use that size, since it could change throughout the
  function.

